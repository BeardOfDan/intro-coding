#+TITLE: Intro to JS Exercises

* Setup

Before beginning, please familiarize yourself with the [[./environment.org][environment]] that we'll be
using.

* Warmup Exercises

If you get stuck on any of these, please do not hesitate to ask for help! The
solutions will be covered in class after the alotted time.

** [[http://codepen.io/jlehman/pen/GoOMGz?editors=001][Part 1: Data]]

These exercises cover the first half of lecture.

** [[http://codepen.io/jlehman/pen/adEZQQ?editors=001][Part 2: Functions & Control Flow]]

These exercises cover the second half of lecture.

* [[http://codepen.io/jlehman/pen/mVqrmw/?editors=001][Project: BookStrap]]

** Exercise 1: Building a Table of Books

This project includes a number of helper functions for constructing a table of
books and adding functionality. Let's explore some of this functionality through
experimentation!

The following sections will involve inserting code into *codepen* in and above
the area marked: ~EXERCISE 1 CODE GOES HERE~

*** 1.1 Experimenting with ~drawTable~

A table consists of /rows/ and /columns/. Usually a /header/ will be the
first row, and will indicate what the contents of each column are.

At this point, you should see an empty table that looks like this:

[[./img/starting-table.png]]

You should also see the following code:

#+begin_src javascript
var tableConfig = {
  headers: [],
  rowKeys: []
}

drawTable([], tableConfig);
#+end_src

+ ~tableConfig~ is a variable that holds an *object*
  + Its keys are ~headers~ and ~rowKeys~
+ ~drawTable~ is a function that takes an array of *rows*, and a configuration
  + The rows are an empty array currently
  + The configuration is ~tableConfig~

Instead of passing an empty array to ~drawTable~ (the first argument), let's try
some sample data.

Add the variable ~foods~:

#+begin_src javascript
var foods = [
  {name: "apple", type: "fruit", delicious: "yes"},
  {name: "ribeye", type: "meat", delicious: "yes"},
  {name: "fruitcake", type: "baked goods", delicious: "not really"}
];
#+end_src

And then update ~drawTable~ like so:

#+begin_src javascript
drawTable(foods, tableConfig);
#+end_src

If everything is working, you should see this:

[[./img/food-table-no-columns.png]]

Something happened! Now we have multiple rows in our table...but there's no
information. Update the ~tableConfig~ to look like this:

#+begin_src javascript
var tableConfig = {
  headers: ["Food"],
  rowKeys: ["name"]
}
#+end_src

[[./img/food-table.png]]

This is looking better! Let's keep going with it:

*Exercises:*

a) Update the ~headers~ and ~rowKeys~ to reflect the food's *type* and
*deliciousness*.

b) Add another key-value pair to each food object (/e.g./ organic, vegan,
gluten-free, color, etc.).

c) Add two more food objects to the array.

*** 1.2 What is the ~bookStore~?

Let's explore the dataset that we'll be working with. In the =INITIALIZATION=
section of the project you'll see ~var bookStore = generateBookStore()~.
~generateBookStore~ is a function that generates the books that we'll be working
with. Enter the following in *codepen*:

#+begin_src javascript
console.log("The books are:", bookStore);
console.log("The length of the bookStore is:", bookStore.length);
#+end_src

Now open up a console (in *codepen*) and see what was logged. You should see something like the
following:

[[./img/sample-output-1a.png]]

It should be apparent at this point that the ~bookStore~ variable is in fact an
*array* of *objects*, where each object represents a *book* that has this
structure:

#+begin_src javascript
{
  author: "Kingsley Amis",
  category: "self help",
  price: 14.4,
  title: "Lucky Jim"
}
#+end_src

*Exercises:*

a) Pass the ~bookStore~ into ~drawTable~ as the first argument. How many rows
are there now?

b) Clear out the ~headers~ and ~rowKeys~ arrays in ~tableConfig~ from the
previous exercise -- add appropriate values for books based on the structure
shown above.

When everything is working, you should see something like this:

[[./img/working-book-store-table.png]]

** Exercise 2: Implement a Search Algorithm

Implementing a search algorithm sounds like a daunting task. Whenever faced with
a problem that seems large, the best strategy is to break it down into a number
of smaller, more manageable subproblems. Instead of concerning ourselves with
searching /all/ of the books, and /all/ of the keys of each book, let's take a
step back and think about some ways in which a search can work.

*** 2.1 Searching the Beginning of Strings

One way to perform a search against strings is to compare the /beginning/ of the
string with some other string that we're searching for.

Let's say we've got a ~"chimpanzee"~ string, and we're trying to see if it
begins with ~"chimp"~.

#+begin_src javascript
var s = "chimpanzee";
var query = "chimp";
#+end_src

JavaScript strings have a method called ~substring~ that takes a starting index
and an ending index as arguments, and returns the string from ~start~ up to
~end~ (does not include the end index). Here's an example:

#+begin_src javascript
// start: 0, end: 3
"chimpanzee".substring(0, 3); // "chi"
// start: 0, end: 5
"chimpanzee".substring(0, 5); // "chimp"
#+end_src

Enter the following into a console (any console is fine) and note what happens:

#+begin_src javascript
var s = "chimpanzee";
var query1 = "chimp";
var query2 = "chip";
s.substring(0, query1.length) === query1;
s.substring(0, query2.length) === query2;
#+end_src

*Exercises*:

a) Use the property demonstrated above to complete the following function:

#+begin_src javascript
function beginsWith(s, query) {
  return // your code here
}
beginsWith("chimpanzee", "chimp"); // true
beginsWith("chimpanzee", "chip"); // false
#+end_src

When you have it working, copy this function to *codepen* where it says:
=EXERCISE 3.1 CODE GOES HERE=

b) Look in *codepen* for the section of code in ~searchBooks~ that looks like this:

#+begin_src javascript
function isMatch(book) {
  // ~~ EXERCISE 3 CODE GOES HERE ~~
  return false; // considers NO book a match
}
#+end_src

Instead of returning ~false~, return ~beginsWith(book.title, query)~. What
happens when you run your search? Try searching for "Lucky" -- does it work?

c) Change ~isMatch~ to work on the book's ~author~ instead of its ~title~.

*** 2.2 Interlude: How does it work?

Now that you have search working, let's take a moment to reflect on how it
works.

#+begin_src javascript
function searchBooks(query) {
  // 1.
  if (query === "") {
    return bookStore;
  }
  // 3.
  function isMatch(book) {
    return beginsWith(book.title, query);
  }
  // 2.
  return filter(bookStore, isMatch);
}
#+end_src

1. The ~if~ statement checks to see if the query is the empty string. If it is,
   it returns all books in the store (~bookStore~).
2. ~filter~ is a function that accepts two arguments: an array, and a function.
   ~filter~ will pass each element in the array to the function, and "keep" only
   the ones that the function returns ~true~ for. It /filters/ out everything
   that the function returns false for.
3. ~isMatch~ is the function that is supplied to ~filter~ -- it accepts one
   argument (in this case we've named it ~book~, since that's what's contained
   in ~bookStore~), and returns ~true~ if the book's title ~beginsWith~ the
   ~query~, and ~false~ otherwise.

*** 2.3 Improved Search

There are two glaring deficiencies in our search algorithm.

1. Try searching for "lucky" (note: you'll need to make sure you're searching on
   ~book.title~ again) -- you should get /no results/. The first book is called
   "Lucky Jim"; why isn't this one of the results?
2. Currently we can only search on one aspect of a book at a time -- what if we
   wanted to search on ~title~, ~author~, /or/ ~category~ without making changes
   to our code?

*Exercises:*

a) The problem in point (1) above has to do with /case sensitivity/: "L" and "l"
are two different characters, and the string "Lucky" is not the same as the
string "lucky". What we need to do is ensure that, for the sake of our search,
the entire string is the same /case/.

Try the following at any console:

#+begin_src javascript
"heLLo WoRld".toLowerCase();
"HEllO WorLD".toUpperCase();
#+end_src

Your solution should work even if you search for "LUcKy JiM".

b) Do you remember the logical /or/ operator from the slides? It looks like
this: ~||~. An expression using ~||~ resolves to ~true~ if /any/ of its operands
are ~true~, and ~false~ if /all/ of its operands are ~false~.

Try the following examples at the console:

#+begin_src javascript
  true || false;
  false || false;
  1 > 2 || 2 < 5;
  // Don't forget to copy-paste the beginsWith function into the console that
  // you're testing in
  beginsWith("chimpanzee", "dog) || beginsWith("chimpanzee", "cat") || beginsWith("chimpanzee", "chimp");
#+end_src

Fix ~isMatch~ to work with the book's ~title~, ~author~ /or/ ~category~.

*** 2.4 Extra Credit: Searching Within Strings

Searching the beginning of a string is all well and good, but what about
arbitrary text /within/ the string? For instance, what if we wanted to test if
"panze" was contained within "chimpanzee"?

There's another string method called ~indexOf~ that returns the /index/ of a a
string if it's contained within another, or ~-1~ if it is not contained within.

Play with it at the console like so:

#+begin_src javascript
"chimpanzee".indexOf("panze");
"chimpanzee".indexOf("chimp");
"chimpanzee".indexOf("p");
"chimpanzee".indexOf("gorilla");
#+end_src

*Exercises:*

a) Write a function ~containedWithin~ (add it below ~beginsWith~) that accepts a
string and a query, and returns ~true~ if the query is contained within the
string, and false if not.

b) Use ~containedWithin~ instead of ~beginsWith~ for your search. Does it work
as you'd expect?

** Exercise 3: Book Selection

Now that we have a table of books and a way to search them, it's time to start
adding books to our shopping cart! Before we get into the thick of it, let's
discuss /methods/.

A *method* is a sort of function that /belongs/ to a piece of data and /does
something/ with that data when it is invoked. As it happens, you have already
worked with a few methods! In Exercise 2, we used ~substring~:

#+begin_src javascript
"hello".substring(0, 3); // "hel"
#+end_src

~substring~ is a /method/ of strings. We can tell because it's a /function/ that
/belongs/ to a string -- note how above ~substring~ is referenced with a *.*
after a string -- ~substring~ makes use of the string it belongs to in order to
give us the result: "hel".

We will be making use of some methods in upcoming examples and exercises. Don't
worry too much about them -- you will not be expected to write your own methods
or discover any on your own -- the ones that we will be using will be mentioned
here and should be intuitive.

The goal of this exercise is to make our app work like this:

[[./img/ex3-add-book-complete.gif]]

First, we need to revisit ~tableConfig~. Change ~tableConfig~ (same one from
Exercise 1) to look like this:

#+begin_src javascript
// Feel free to leave your headers and rowKeys unchanged
var tableConfig = {
  headers: ["Title", "Author", "Genre", "Price"],
  rowKeys: ["title", "author", "category", "price"], // don't forget the comma!
  rowClicked: rowClicked // this is the new part
}
#+end_src

Now, try clicking on a few rows with the console open (in *codepen*). What
happens? Find the section in the code for =Exercise 4= -- the ~rowClicked~
function is what is now being executed whenever a row is clicked:

#+begin_src javascript
function rowClicked(book, row) {
  console.log("Clicked book:", book);
}
#+end_src

What we're trying to achieve is twofold:
1. Highlight the selected rows
2. Add/remove books from the ~shoppingCart~

The ~rowClicked~ function is called with two arguments: ~book~ and ~row~.
+ *book* is what you'd expect -- a familiar book object.
+ *row* is a special object that exposes some methods to manipulate its visual
  state.

This is where methods enter the picture! The ~shoppingCart~ comes with a method
~add~ that takes a book as an argument and /adds/ it to the shopping cart. Try
it by putting this inside ~rowClicked~:

#+begin_src javascript
shoppingCart.add(book);
#+end_src

What happens when you click on a book now? You should see the amount inside of
the button in the upper right corner increase by the price of the book. There's
a problem though: clicking a book multiple times seems to add the book multiple
times -- ideally, we'd like clicking on the same book to /remove/ the book.

*Exercises:*

a) The ~shoppingCart~ has two other methods that we can use: ~remove~ and
~contains~ -- each of which also take a book as an argument.
+ ~shoppingCart.remove(book)~ will remove the book from the cart (if it is there)
+ ~shoppingCart.contains(book)~ will return ~true~ if the book is contained in
  the cart, and ~false~ otherwise.

Use this information to implement ~rowClicked~ such that *if* the book is *not*
*contained* in the shopping cart, it is *added* to it; otherwise (if it *is*
contained in the cart), the book is *removed* from the shopping cart.

b) The ~row~ argument to ~rowClicked~ is an object whose visual state can be
manipulated with methods. Two of these are:
+ ~row.highlight()~: highlights the row, and
+ ~row.unhighlight()~: unhighlights the row

Use this to modify ~rowClicked~ so that books contained within the shopping cart
are highlighted, and those that are not in the shopping cart are not
highlighted.

** Exercise 4: Show/Hide the Checkout Form

Great! Clearly something is happening with our shopping cart; the next step is
to display the form that we'll use to "purchase" our books. Our goal for the end
of this exercise is to get our app to work like this:

[[./img/ex4-checkout-form-complete.gif]]

We have to functions to implement for this exercise. Find the section of code
that looks like this in *codepen*:

#+begin_src javascript
function startCheckout() {
  console.log("Clicked the cart button!");
  // ~~ EXERCISE 4 CODE GOES HERE ~~
}

function cancelCheckout() {
  console.log("Cancelling checkout.");
  // ~~ EXERCISE 4 CODE GOES HERE ~~
}
#+end_src

Open up a console in *codepen* if you don't have one open already. If you click
the cart button in the upper right corner (above the blue Search button), do you
see "Clicked the cart button!" message?

Our first order of business is to show form when the cart button is clicked.
Inside of ~startCheckout~, enter the following and see what happens when you
click the cart button again.

#+begin_src javascript
views.cartForm.show(); // yet another method
#+end_src

The ~views~ (you can see it in the =HELPERS= section -- just scroll down a bit)
object holds a number of references to various aspects of the page -- all of
these views can be hidden or shown with the ~hide~ and ~show~ methods, /e.g./:

#+begin_src javascript
views.cartForm.show(); // shows the cart form
views.cartForm.hide(); // hides the cart form
views.searchBar.hide(); // hides the entire search bar
views.buttons.search.hide(); // hides just the search button
#+end_src

We can also ask a view if it is hidden or shown like so:

#+begin_src javascript
views.cartForm.show(); // show the cart form
views.cartForm.hidden(); // false
views.cartForm.hide(); // hide the cart form
views.cartForm.hidden(); // true
#+end_src

*Exercises:*

a) Whenever the ~startCheckout~ function is called (when the cart button is
clicked), the cart form should be shown. Using the above methods, make this
happen.

b) Whenever the ~cancelCheckout~ function is called (when the cancel button in
the form is clicked), the form should be hidden. Use the above methods to
accomplish this.

c) It would be really nice if, when the cart was shown, the table updated to
just reflect the books that are in the cart. We can ask the ~shoppingCart~ to
give us the books that it holds with the ~shoppingCart.books()~ method. Add a
~console.log(shoppingCart.books())~ to the end of ~rowClicked~ (from the last
exercise) to see the value of ~shoppingCart.books()~ as books are added.

Remember the ~drawTable~ function? Use ~drawTable~ in conjunction with
~shoppingCart.books()~ to update the table to show just those books that are in
the cart when the cart is shown, and all of the books when it is hidden.

d) Finally, searching the books while getting ready to check out doesn't make
much sense. Let's also hide the ~views.searchBar~ whenever the ~views.cartForm~
is shown.

*EXTRA CREDIT*: You can use ~views.alert.display("Some message")~ to display an
error message at the top of the screen. Since it doesn't make sense to allow
someone to check out with an empty cart, update ~startCheckout~ so that if there
are no books in the cart (hint: use ~shoppingCart.books().length~) an error is
displayed instead of the cart being shown. You'll also need to think about when
the alert should be hidden!

** Exercise 5: Complete the Checkout

TODO:
