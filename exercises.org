#+TITLE: Intro to JS Exercises

* [[http://codepen.io/jlehman/pen/GoOMGz?editors=001][Warmup]]

Get as far through the warmup exercises as you can.

* [[http://codepen.io/jlehman/pen/mVqrmw/?editors=001][Project 1: Book Store]]

** Exercise 1: Building a Table

The Book Store project includes a number of helper functions for constructing a
table of books. Let's explore some of these functions to see how they work.

*a)* Let's start by exploring the dataset that we'll be working with. In the
=INITIALIZATION= section of the project you'll see ~var bookStore =
generateBookStore()~. ~generateBookStore~ is a function that generates the books
that we'll be working with. Open a console and enter the following:

#+begin_src javascript
console.log("The books are:", bookStore);
console.log("The length of the bookStore is:", bookStore.length);
#+end_src

We can use ~console.log~ to see what's happening inside our programs. To see
what was logged, open a console:

#+CAPTION: How to open a console
[[./img/open-console.png]]

What kind of data structure is ~bookStore~? How many books does it contain? What
kind of data structure is each book? Make sure to interact with the logged
output. You should see something like the following:

#+CAPTION: Sample output
[[./img/sample-output-1a.png]]

*b)* A table consists of /rows/ and /columns/. Usually a /header/ will be the
first row, and will indicate what the contents of each column are. A JavaScript
(JS) function has been provided to work with the header of the table called
~setTableHeader~. It takes one argument -- an array of strings that will be
turned into header names. Try entering the following in your code:

#+begin_src javascript
setTableHeader([]);
setTableHeader(["Hello"]);
setTableHeader(["Hello", "World"]);
#+end_src

You've already seen what a single book object looks like. Change the call to
~setTableHeader~ to contain the appropriate header values based the keys present
in each book. Try playing with the order of the header strings -- does the order
matter?

*c)* Now that we have a header, it's time to add the content (the /rows/). A
similar function for accomplishing this is provided: ~setTableBody~. This
function accepts two arguments: an array of objects, and an array of strings
that represent names of keys in each object. Let's play with it a bit:

#+begin_src javascript
var objects = [{a: "Hello", b: "World"}, {a: "Dog", b: "Cat"}, {a: "Orange", b: "Banana"}];
setTableHeader(["A", "B"]);
setTableBody(objects, ["a", "b"]);
#+end_src

Use ~setTableBody~ to display a table of books.

** Exercise 2: Set up Search

#+begin_src javascript
byId("search-button").addEventListener('click', function() {
  var query = byId("search-input").value
  // Let's make some searching happen.
});
#+end_src

There's a function in the ~BOOK STORE: Searching~ section called ~searchBooks~
that, given a query, searches books. Currently ~searchBooks~ does a really bad
job; if the query is an empty string (nothing input in the search bar) has been
entered, it'll return all the books. If /anything/ is entered, it'll return *an
empty array* indicating that there are no matches. Making the search work better
is the subject of the next exercise -- first, let's hook up the search button to
perform the search (even though the search isn't very good yet) when it is
clicked.

*a)* ~searchBooks~ takes a single argument -- a query to search books against --
and returns a *new array of books*. You can experiment with ~searchBooks~ like so:

#+begin_src javascript
console.log("The result of the search is: ", searchBooks(query));
#+end_src

Try adding the above line and pressing the search button both with /nothing/
entered in the search field, and with /anything/ entered in the search field.
What happens?

*b)* Instead of logging the result, we want the table to update based on the
output of ~searchBooks~. What have we used so far that allows us to set the body
of the table based on an array of books? Use that function to update the table
whenever the search button is pressed.

** Exercise 3: Implement a Search Algorithm

#+begin_src javascript
function isMatch(book) {
  return false; // this is a really bad search
}
#+end_src

The ~isMatch~ function will be called on each book in the ~bookStore~, and
should *return* ~true~ if that book is a match, and ~false~ if not. We'll now
explore a couple of techniques for implementing the search algorithm. When
implementing this function, don't forget ~return~ true or false!

*a)* One way to search our books would be to check if the beginning of the book's
title (=book.title=) was equal to our =query=. JavaScript strings have a method
=substring= that takes two arguments: =begin= and =end=. Try the following at a
console:

#+begin_src javascript
"hello, world".substring(0,3);
"hello, world".substring(3,7);
#+end_src

Given that we can determine the length of our =query= with =query.length=, and
can check equality with ~===~, how can we use =substring= to determine if the
beginning of the book's title matches the =query=?

*b)* How does your =isMatch= function fare with different cases? Change =isMatch=
to be case-insensitive. Hint: try a search for "javascript lowercase string" in
Google.

*c)* Modify =isMatch= to search against a different key in the =book= object (e.g.
author). Having to modify the code itself to search against a different field
doesn't seem like a very good solution; ideally we would like to be able to
search by title /or/ author -- fix this by using the logical *or* operator
(~||~) to check against multiple keys at once. Try the following at a console to
get an idea of how ~||~ works:

#+begin_src javascript
true || true
true || false
false || false
var animal = "monkey";
animal === "giraffe" || animal === "monkey"
#+end_src

*d)* Let's say we're searching for the book "Infinite Jest", and we try searching
for the word "jest" -- does the search work? Why not? Change =isMatch= again so
that it does. The string method =indexOf= can help us here. Try the following to
get an idea of what =indexOf= does:

#+begin_src javascript
"hello, world".indexOf("hello");
"hello, world".indexOf("wor");
"hello, world".indexOf(", w");
"hello, world".indexOf("chimpanzee");
#+end_src
** Exercise 4: Don't Repeat Yourself (DRY)

*a)* You have probably made several calls to ~setTableBody~ at this point, and
 have probably noticed that it was necessary to supply the array of keys as the
 second argument each time -- this is annoying. Let's fix it! First, create a
 new function called ~updateTable~.

 Look at your previous calls to ~setTableBody~ -- of the parameters that you
 have passed to this function, which parameter has changed and which parameter
 has stayed the same? Your new ~updateTable~ function should only take /one/
 argument -- the one that has changed between calls.

*b)* Instead of calling ~setTableBody~ multiple times with arguments that don't
change, we'll /wrap/ calls to ~setTableBody~ with ~updateTable~ so that the
unchanging arguments can be provided *once*, and we can focus on the arguments
that /do/ change. Consider the following example:

#+begin_src javascript
function add(x, y) {
  return x + y;
}
// Let's say we find ourselves adding 10 frequently to some other number:
add(10, 17);
add(10, 3);
add(10, 4);
// Why not have an addTen function?
function addTen(x) {
  return add(10, x);
}
#+end_src

Call ~setTableBody~ inside of ~updateTable~ and provide the unchanging arguments
here. Afterwards, replace all of your previous calls to ~setTableBody~ with
calls to ~updateTable~.
** Exercise 5: Extending Table Functionality

In Exercise 1 we told you that ~setTableBody~ accepted an array of row objects
and an array of string key names to use to look up values from the row objects.
In addition to strings, the second argument can also contain /objects/ -- this
allows us to inject some additional functionality into the table -- specifically
where formatting is concerned. Let's revisit the example in Exercise 1 and see
how this works:

#+begin_src javascript
var objects = [{a: "Hello", b: "World"}, {a: "Dog", b: "Cat"}, {a: "Orange", b: "Banana"}];
function formatA(x) {
  return x + "!";
}

function formatB(x) {
  return x.toUpperCase();
}
setTableBody(objects, [{key: "a", format: formatA},
                       {key: "b", format: formatB}]);
#+end_src

By providing a formatting function, we can alter the way the data /appears/
without altering the data itself.

*a)* Inside of your ~updateTable~ function from the last exercise, declare a new
 function ~formatPrice~ that prefixes the price with a dollar sign (hint: see
 ~formatA~ above for an example of how to do this); then, format the ~price~
 column of each book.

*b)* Pick one of the authors of the books and create a formatting function that
 replaces that author's name with your own.

*c)* ~setTableBody~ can also take a function as a third argument, that, when
  provided, will be called whenever a row is clicked. This function should take
  two arguments: ~book~ and ~row~. Declare this function inside of ~updateTable~
  and pass it as the third argument to ~updateTable~. For now, just
  ~console.log~ the book object (first parameter) inside of the function.
