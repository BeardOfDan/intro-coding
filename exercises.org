#+TITLE: Intro to JS Exercises

* Setup

Before beginning, please familiarize yourself with the [[./environment.org][environment]] that we'll be
using.

* [[http://codepen.io/jlehman/pen/GoOMGz?editors=001][Warmup]]

Get as far through the warmup exercises as you can.

* [[http://codepen.io/jlehman/pen/mVqrmw/?editors=001][Project: Book Store]]

** Exercise 1: Building a Table of Books

This project includes a number of helper functions for constructing a table of
books and adding functionality. Let's explore some of this functionality through
experimentation!

The following sections will involve inserting code into *codepen* in and above
the area marked: ~EXERCISE 1 CODE GOES HERE~

*** 1.1 Experimenting with ~drawTable~

A table consists of /rows/ and /columns/. Usually a /header/ will be the
first row, and will indicate what the contents of each column are.

At this point, you should see an empty table that looks like this:

[[./img/starting-table.png]]

You should also see the following code:

#+begin_src javascript
var tableConfig = {
  headers: [],
  rowKeys: []
}

drawTable([], tableConfig);
#+end_src

+ ~tableConfig~ is a variable that holds an *object*
  + Its keys are ~headers~ and ~rowKeys~
+ ~drawTable~ is a function that takes an array of *rows*, and a configuration
  + The rows are an empty array currently
  + The configuration is ~tableConfig~

Instead of passing an empty array to ~drawTable~ (the first argument), let's try
some sample data. Add the following variable ~food~ and update ~drawTable~ like
so:

#+begin_src javascript
var foods = [
  {name: "apple", type: "fruit", delicious: "yes"},
  {name: "ribeye", type: "meat", delicious: "yes"},
  {name: "fruitcake", type: "baked goods", delicious: "not really"}
];
drawTable(food, tableConfig);
#+end_src

If everything is working, you should see this:

[[./img/food-table-no-columns.png]]

Something happened! Now we have multiple rows in our table...but there's no
information. Update the ~tableConfig~ to look like this:

#+begin_src javascript
var tableConfig = {
  headers: ["Food"],
  rowKeys: ["name"]
}
#+end_src

[[./img/food-table.png]]

This is looking better! Let's keep going with it:

*Exercises:*

a) Update the ~headers~ and ~rowKeys~ to reflect the food's *type* and
*deliciousness*.

b) Add another key-value pair to each food object (/e.g./ organic, vegan,
gluten-free, color, etc.).

c) Add two more food objects to the array.

*** 1.2 What is the ~bookStore~?

Let's explore the dataset that we'll be working with. In the =INITIALIZATION=
section of the project you'll see ~var bookStore = generateBookStore()~.
~generateBookStore~ is a function that generates the books that we'll be working
with. Enter the following in *codepen*:

#+begin_src javascript
console.log("The books are:", bookStore);
console.log("The length of the bookStore is:", bookStore.length);
#+end_src

Now open up a console (in *codepen*) and see what was logged. You should see something like the
following:

[[./img/sample-output-1a.png]]

It should be apparent at this point that the ~bookStore~ variable is in fact an
*array* of *objects*, where each object represents a *book* that has this
structure:

#+begin_src javascript
{
  author: "Kingsley Amis",
  category: "self help",
  price: 14.4,
  title: "Lucky Jim"
}
#+end_src

*Exercises:*

a) Pass the ~bookStore~ into ~drawTable~ as the first argument. How many rows
are there now?

b) Clear out the ~headers~ and ~rowKeys~ arrays in ~tableConfig~ from the
previous exercise -- add appropriate values for books based on the structure
shown above.

When everything is working, you should see something like this:

[[./img/working-book-store-table.png]]

** Exercise 2: Set up Search

Open the console (in *codepen*, not here), enter some text in the search books
field, and press the search button. You should see something like this:

[[./img/ex2-search-console.png]]

This is the code that makes this happen:

#+begin_src javascript
function shouldPerformSearch(query) {
  console.log("You clicked the search button! The query is:", query);
  // ~~ EXERCISE 2 CODE GOES HERE ~~
}
#+end_src

Whenever the blue *Search* button is clicked, the ~shouldPerformSearch~ function
is called. Given the name, we should expect that this function performs a
search, but right now it doesn't do much of anything!

Right below ~shouldPerformSearch~ is the function ~searchBooks~.

#+begin_src javascript
function searchBooks(query) {
  // body omitted
}
#+end_src

In the next exercise we'll be focusing on making ~searchBooks~ perform a decent
search; for now, let's just see how it works. Notice how ~searchBooks~ takes a
single argument, ~query~? Instead of logging the ~query~ itself, let's see what
happens when we call ~searchBooks~ with the query. Change ~shouldPerformSearch~
to look like this:

#+begin_src javascript
function shouldPerformSearch(query) {
  console.log("Your search returned:", searchBooks(query));
}
#+end_src

What happens when you press the search button without any text in the field?
What about when there is text?

[[./img/log-basic-search.gif]]

Clearly, the search needs some work. As mentioned before, we'll fix this later;
for now, we can just pretend that it works well and use it regardless.

*Exercises:*

a) Currently, the search either returns an empty array, or an array of books
(this should make sense -- either the search will match nothing, some of the
books, or all of the books). Use this information to update the table
(~drawTable~) with the result of ~searchBooks~.

b) What happens when you use the search button now? Like before, try it with no
text entered and with text entered. Given the result we saw earlier, does this
make sense?

** Exercise 3: Implement a Search Algorithm

Implementing a search algorithm sounds like a daunting task. Whenever faced with
a problem that seems large, the best strategy is to break it down into a number
of smaller, more manageable subproblems. Instead of concerning ourselves with
searching /all/ of the books, and /all/ of the keys of each book, let's take a
step back and think about some ways in which a search can work.

*** 3.1 Searching the Beginning of Strings

One way to perform a search against strings is to compare the /beginning/ of the
string with some other string that we're searching for.

Let's say we've got a ~"chimpanzee"~ string, and we're trying to see if it
begins with ~"chimp"~.

#+begin_src javascript
var s = "chimpanzee";
var query = "chimp";
#+end_src

JavaScript strings have a method called ~substring~ that takes a starting index
and an ending index as arguments, and returns the string from ~start~ up to
~end~ (does not include the end index). Here's an example:

#+begin_src javascript
// start: 0, end: 3
"chimpanzee".substring(0, 3); // "chi"
// start: 0, end: 5
"chimpanzee".substring(0, 5); // "chimp"
#+end_src

Enter the following into a console (any console is fine) and note what happens:

#+begin_src javascript
var s = "chimpanzee";
var query1 = "chimp";
var query2 = "chip";
s.substring(0, query1.length) === query1;
s.substring(0, query2.length) === query2;
#+end_src

*Exercises*:

a) Use the property demonstrated above to complete the following function:

#+begin_src javascript
function beginsWith(s, query) {
  return // your code here
}
beginsWith("chimpanzee", "chimp"); // true
beginsWith("chimpanzee", "chip"); // false
#+end_src

When you have it working, copy this function to *codepen* where it says:
=EXERCISE 3.1 CODE GOES HERE=

b) Look in *codepen* for the section of code in ~searchBooks~ that looks like this:

#+begin_src javascript
function isMatch(book) {
  // ~~ EXERCISE 3 CODE GOES HERE ~~
  return false; // considers NO book a match
}
#+end_src

Instead of returning ~false~, return ~beginsWith(book.title, query)~. What
happens when you run your search? Try searching for "Lucky" -- does it work?

** Exercise 4: Don't Repeat Yourself (DRY)

*a)* You have probably made several calls to ~setTableBody~ at this point, and
 have probably noticed that it was necessary to supply the array of keys as the
 second argument each time -- this is annoying. Let's fix it! First, create a
 new function called ~updateTable~.

 Look at your previous calls to ~setTableBody~ -- of the parameters that you
 have passed to this function, which parameter has changed and which parameter
 has stayed the same? Your new ~updateTable~ function should only take /one/
 argument -- the one that has changed between calls.

*b)* Instead of calling ~setTableBody~ multiple times with arguments that don't
change, we'll /wrap/ calls to ~setTableBody~ with ~updateTable~ so that the
unchanging arguments can be provided *once*, and we can focus on the arguments
that /do/ change. Consider the following example:

#+begin_src javascript
function add(x, y) {
  return x + y;
}
// Let's say we find ourselves adding 10 frequently to some other number:
add(10, 17);
add(10, 3);
add(10, 4);
// Why not have an addTen function?
function addTen(x) {
  return add(10, x);
}
#+end_src

Call ~setTableBody~ inside of ~updateTable~ and provide the unchanging arguments
here. Afterwards, replace all of your previous calls to ~setTableBody~ with
calls to ~updateTable~.
** Exercise 5: Extending Table Functionality

In Exercise 1 we told you that ~setTableBody~ accepted an array of row objects
and an array of string key names to use to look up values from the row objects.
In addition to strings, the second argument can also contain /objects/ -- this
allows us to inject some additional functionality into the table -- specifically
where formatting is concerned. Let's revisit the example in Exercise 1 and see
how this works:

#+begin_src javascript
var objects = [{a: "Hello", b: "World"}, {a: "Dog", b: "Cat"}, {a: "Orange", b: "Banana"}];
function formatA(x) {
  return x + "!";
}

function formatB(x) {
  return x.toUpperCase();
}
setTableBody(objects, [{key: "a", format: formatA},
                       {key: "b", format: formatB}]);
#+end_src

By providing a formatting function, we can alter the way the data /appears/
without altering the data itself.

*a)* Inside of your ~updateTable~ function from the last exercise, declare a new
 function ~formatPrice~ that prefixes the price with a dollar sign (hint: see
 ~formatA~ above for an example of how to do this); then, format the ~price~
 column of each book.

*b)* Pick one of the authors of the books and create a formatting function that
 replaces that author's name with your own.

*c)* ~setTableBody~ can also take a function as a third argument, that, when
  provided, will be called whenever a row is clicked. This function should take
  two arguments: ~book~ and ~row~. Declare this function inside of ~updateTable~
  and pass it as the third argument to ~updateTable~. For now, just
  ~console.log~ the book object (first parameter) inside of the function.
