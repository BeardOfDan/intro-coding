#+TITLE: Intro to JS Exercises

* Setup

Before beginning, please familiarize yourself with the [[./environment.org][environment]] that we'll be
using.

* [[http://codepen.io/jlehman/pen/GoOMGz?editors=001][Warmup]]

Get as far through the warmup exercises as you can.

* [[http://codepen.io/jlehman/pen/mVqrmw/?editors=001][Project: Book Store]]

** Exercise 1: Building a Table of Books

This project includes a number of helper functions for constructing a table of
books and adding functionality. Let's explore some of this functionality through
experimentation!

The following sections will involve inserting code into *codepen* in and above
the area marked: ~EXERCISE 1 CODE GOES HERE~

*** 1.1 Experimenting with ~drawTable~

A table consists of /rows/ and /columns/. Usually a /header/ will be the
first row, and will indicate what the contents of each column are.

At this point, you should see an empty table that looks like this:

[[./img/starting-table.png]]

You should also see the following code:

#+begin_src javascript
var tableConfig = {
  headers: [],
  rowKeys: []
}

drawTable([], tableConfig);
#+end_src

+ ~tableConfig~ is a variable that holds an *object*
  + Its keys are ~headers~ and ~rowKeys~
+ ~drawTable~ is a function that takes an array of *rows*, and a configuration
  + The rows are an empty array currently
  + The configuration is ~tableConfig~

Instead of passing an empty array to ~drawTable~ (the first argument), let's try
some sample data.

Add the variable ~foods~:

#+begin_src javascript
var foods = [
  {name: "apple", type: "fruit", delicious: "yes"},
  {name: "ribeye", type: "meat", delicious: "yes"},
  {name: "fruitcake", type: "baked goods", delicious: "not really"}
];
#+end_src

And then update ~drawTable~ like so:

#+begin_src javascript
drawTable(foods, tableConfig);
#+end_src

If everything is working, you should see this:

[[./img/food-table-no-columns.png]]

Something happened! Now we have multiple rows in our table...but there's no
information. Update the ~tableConfig~ to look like this:

#+begin_src javascript
var tableConfig = {
  headers: ["Food"],
  rowKeys: ["name"]
}
#+end_src

[[./img/food-table.png]]

This is looking better! Let's keep going with it:

*Exercises:*

a) Update the ~headers~ and ~rowKeys~ to reflect the food's *type* and
*deliciousness*.

b) Add another key-value pair to each food object (/e.g./ organic, vegan,
gluten-free, color, etc.).

c) Add two more food objects to the array.

*** 1.2 What is the ~bookStore~?

Let's explore the dataset that we'll be working with. In the =INITIALIZATION=
section of the project you'll see ~var bookStore = generateBookStore()~.
~generateBookStore~ is a function that generates the books that we'll be working
with. Enter the following in *codepen*:

#+begin_src javascript
console.log("The books are:", bookStore);
console.log("The length of the bookStore is:", bookStore.length);
#+end_src

Now open up a console (in *codepen*) and see what was logged. You should see something like the
following:

[[./img/sample-output-1a.png]]

It should be apparent at this point that the ~bookStore~ variable is in fact an
*array* of *objects*, where each object represents a *book* that has this
structure:

#+begin_src javascript
{
  author: "Kingsley Amis",
  category: "self help",
  price: 14.4,
  title: "Lucky Jim"
}
#+end_src

*Exercises:*

a) Pass the ~bookStore~ into ~drawTable~ as the first argument. How many rows
are there now?

b) Clear out the ~headers~ and ~rowKeys~ arrays in ~tableConfig~ from the
previous exercise -- add appropriate values for books based on the structure
shown above.

When everything is working, you should see something like this:

[[./img/working-book-store-table.png]]

** Exercise 2: Set up Search

Open the console (in *codepen*, not here), enter some text in the search books
field, and press the search button. You should see something like this:

[[./img/ex2-search-console.png]]

This is the code that makes this happen:

#+begin_src javascript
function shouldPerformSearch(query) {
  console.log("You clicked the search button! The query is:", query);
  // ~~ EXERCISE 2 CODE GOES HERE ~~
}
#+end_src

Whenever the blue *Search* button is clicked, the ~shouldPerformSearch~ function
is called. Given the name, we should expect that this function performs a
search, but right now it doesn't do much of anything!

Right below ~shouldPerformSearch~ is the function ~searchBooks~.

#+begin_src javascript
function searchBooks(query) {
  // body omitted
}
#+end_src

In the next exercise we'll be focusing on making ~searchBooks~ perform a decent
search; for now, let's just see how it works. Notice how ~searchBooks~ takes a
single argument, ~query~? Instead of logging the ~query~ itself, let's see what
happens when we call ~searchBooks~ with the query. Change ~shouldPerformSearch~
to look like this:

#+begin_src javascript
function shouldPerformSearch(query) {
  console.log("Your search returned:", searchBooks(query));
}
#+end_src

What happens when you press the search button without any text in the field?
What about when there is text?

[[./img/log-basic-search.gif]]

Clearly, the search needs some work. As mentioned before, we'll fix this later;
for now, we can just pretend that it works well and use it regardless.

*Exercises:*

a) Currently, the search either returns an empty array, or an array of books
(this should make sense -- either the search will match nothing, some of the
books, or all of the books). Inside of ~shouldPerformSearch~, call the
~drawTable~ function with the result of ~searchBooks~ to update the table
whenever the search button is clicked.

b) What happens when you use the search button now? Like before, try it with no
text entered and with text entered. Given the result we saw earlier, does this
make sense?

** Exercise 3: Implement a Search Algorithm

Implementing a search algorithm sounds like a daunting task. Whenever faced with
a problem that seems large, the best strategy is to break it down into a number
of smaller, more manageable subproblems. Instead of concerning ourselves with
searching /all/ of the books, and /all/ of the keys of each book, let's take a
step back and think about some ways in which a search can work.

*** 3.1 Searching the Beginning of Strings

One way to perform a search against strings is to compare the /beginning/ of the
string with some other string that we're searching for.

Let's say we've got a ~"chimpanzee"~ string, and we're trying to see if it
begins with ~"chimp"~.

#+begin_src javascript
var s = "chimpanzee";
var query = "chimp";
#+end_src

JavaScript strings have a method called ~substring~ that takes a starting index
and an ending index as arguments, and returns the string from ~start~ up to
~end~ (does not include the end index). Here's an example:

#+begin_src javascript
// start: 0, end: 3
"chimpanzee".substring(0, 3); // "chi"
// start: 0, end: 5
"chimpanzee".substring(0, 5); // "chimp"
#+end_src

Enter the following into a console (any console is fine) and note what happens:

#+begin_src javascript
var s = "chimpanzee";
var query1 = "chimp";
var query2 = "chip";
s.substring(0, query1.length) === query1;
s.substring(0, query2.length) === query2;
#+end_src

*Exercises*:

a) Use the property demonstrated above to complete the following function:

#+begin_src javascript
function beginsWith(s, query) {
  return // your code here
}
beginsWith("chimpanzee", "chimp"); // true
beginsWith("chimpanzee", "chip"); // false
#+end_src

When you have it working, copy this function to *codepen* where it says:
=EXERCISE 3.1 CODE GOES HERE=

b) Look in *codepen* for the section of code in ~searchBooks~ that looks like this:

#+begin_src javascript
function isMatch(book) {
  // ~~ EXERCISE 3 CODE GOES HERE ~~
  return false; // considers NO book a match
}
#+end_src

Instead of returning ~false~, return ~beginsWith(book.title, query)~. What
happens when you run your search? Try searching for "Lucky" -- does it work?

c) Change ~isMatch~ to work on the book's ~author~ instead of its ~title~.

*** 3.2 Interlude: How does it work?

Now that you have search working, let's take a moment to reflect on how it
works.

#+begin_src javascript
function searchBooks(query) {
  // 1.
  if (query === "") {
    return bookStore;
  }
  // 3.
  function isMatch(book) {
    return beginsWith(book.title, query);
  }
  // 2.
  return filter(bookStore, isMatch);
}
#+end_src

1. The ~if~ statement checks to see if the query is the empty string. If it is,
   it returns all books in the store (~bookStore~).
2. ~filter~ is a function that accepts two arguments: an array, and a function.
   ~filter~ will pass each element in the array to the function, and "keep" only
   the ones that the function returns ~true~ for. It /filters/ out everything
   that the function returns false for.
3. ~isMatch~ is the function that is supplied to ~filter~ -- it accepts one
   argument (in this case we've named it ~book~, since that's what's contained
   in ~bookStore~), and returns ~true~ if the book's title ~beginsWith~ the
   ~query~, and ~false~ otherwise.

*** 3.3 Improved Search

There are two glaring deficiencies in our search algorithm.

1. Try searching for "lucky" (note: you'll need to make sure you're searching on
   ~book.title~ again) -- you should get /no results/. The first book is called
   "Lucky Jim"; why isn't this one of the results?
2. Currently we can only search on one aspect of a book at a time -- what if we
   wanted to search on ~title~, ~author~, /or/ ~category~ without making changes
   to our code?

*Exercises:*

a) The problem in point (1) above has to do with /case sensitivity/: "L" and "l"
are two different characters, and the string "Lucky" is not the same as the
string "lucky". What we need to do is ensure that, for the sake of our search,
the entire string is the same /case/.

Try the following at any console:

#+begin_src javascript
"heLLo WoRld".toLowerCase();
"HEllO WorLD".toUpperCase();
#+end_src

Your solution should work even if you search for "LUcKy JiM".

b) Do you remember the logical /or/ operator from the slides? It looks like
this: ~||~. An expression using ~||~ resolves to ~true~ if /any/ of its operands
are ~true~, and ~false~ if /all/ of its operands are ~false~.

Try the following examples at the console:

#+begin_src javascript
  true || false;
  false || false;
  1 > 2 || 2 < 5;
  // Don't forget to copy-paste the beginsWith function into the console that
  // you're testing in
  beginsWith("chimpanzee", "dog) || beginsWith("chimpanzee", "cat") || beginsWith("chimpanzee", "chimp");
#+end_src

Fix ~isMatch~ to work with the book's ~title~, ~author~ /or/ ~category~.

*** 3.4 Extra Credit: Searching Within Strings

Searching the beginning of a string is all well and good, but what about
arbitrary text /within/ the string? For instance, what if we wanted to test if
"panze" was contained within "chimpanzee"?

There's another string method called ~indexOf~ that returns the /index/ of a a
string if it's contained within another, or ~-1~ if it is not contained within.

Play with it at the console like so:

#+begin_src javascript
"chimpanzee".indexOf("panze");
"chimpanzee".indexOf("chimp");
"chimpanzee".indexOf("p");
"chimpanzee".indexOf("gorilla");
#+end_src

*Exercises:*

a) Write a function ~containedWithin~ (add it below ~beginsWith~) that accepts a
string and a query, and returns ~true~ if the query is contained within the
string, and false if not.

b) Use ~containedWithin~ instead of ~beginsWith~ for your search. Does it work
as you'd expect?
