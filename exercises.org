#+TITLE: Intro to JS Exercises

* Setup

Before beginning, please familiarize yourself with the [[./environment.org][environment]] that we'll be
using.

* [[http://codepen.io/jlehman/pen/GoOMGz?editors=001][Warmup]]

Get as far through the warmup exercises as you can.

* [[http://codepen.io/jlehman/pen/mVqrmw/?editors=001][Project: Book Store]]

** Exercise 1: Building a Table of Books

This project includes a number of helper functions for constructing a table of
books and adding functionality. Let's explore some of this functionality through
experimentation!

The following sections will involve inserting code into *codepen* in and above
the area marked: ~EXERCISE 1 CODE GOES HERE~

*** 1.1 Experimenting with ~drawTable~

A table consists of /rows/ and /columns/. Usually a /header/ will be the
first row, and will indicate what the contents of each column are.

At this point, you should see an empty table that looks like this:

[[./img/starting-table.png]]

You should also see the following code:

#+begin_src javascript
var tableConfig = {
  headers: [],
  rowKeys: []
}

drawTable([], tableConfig);
#+end_src

+ ~tableConfig~ is a variable that holds an *object*
  + Its keys are ~headers~ and ~rowKeys~
+ ~drawTable~ is a function that takes an array of *rows*, and a configuration
  + The rows are an empty array currently
  + The configuration is ~tableConfig~

Instead of passing an empty array to ~drawTable~ (the first argument), let's try
some sample data. Add the following variable ~food~ and update ~drawTable~ like
so:

#+begin_src javascript
var foods = [
  {name: "apple", type: "fruit", delicious: "yes"},
  {name: "ribeye", type: "meat", delicious: "yes"},
  {name: "fruitcake", type: "baked goods", delicious: "not really"}
];
drawTable(food, tableConfig);
#+end_src

If everything is working, you should see this:

[[./img/food-table-no-columns.png]]

Something happened! Now we have multiple rows in our table...but there's no
information. Update the ~tableConfig~ to look like this:

#+begin_src javascript
var tableConfig = {
  headers: ["Food"],
  rowKeys: ["name"]
}
#+end_src

[[./img/food-table.png]]

This is looking better! Let's keep going with it:

*Exercises:*

a) Update the ~headers~ and ~rowKeys~ to reflect the food's *type* and
*deliciousness*.

b) Add another key-value pair to each food object (/e.g./ organic, vegan,
gluten-free, color, etc.).

c) Add two more food objects to the array.

*** 1.2 What is the ~bookStore~?

Let's explore the dataset that we'll be working with. In the =INITIALIZATION=
section of the project you'll see ~var bookStore = generateBookStore()~.
~generateBookStore~ is a function that generates the books that we'll be working
with. Enter the following in *codepen*:

#+begin_src javascript
console.log("The books are:", bookStore);
console.log("The length of the bookStore is:", bookStore.length);
#+end_src

Now open up a console and see what was logged. You should see something like the
following:

[[./img/sample-output-1a.png]]

It should be apparent at this point that the ~bookStore~ variable is in fact an
*array* of *objects*, where each object represents a *book* that has this
structure:

#+begin_src javascript
{
  author: "Kingsley Amis",
  category: "self help",
  price: 14.4,
  title: "Lucky Jim"
}
#+end_src

*Exercises:*

a) Pass the ~bookStore~ into ~drawTable~ as the first argument. How many rows
are there now?

b) Clear out the ~headers~ and ~rowKeys~ arrays in ~tableConfig~ from the
previous exercise -- add appropriate values for books based on the structure
shown above.

When everything is working, you should see something like this:

[[./img/working-book-store-table.png]]

** Exercise 2: Set up Search

Open the console, enter some text in the search books field, and press the
search button. You should see something like this:

[[./img/ex2-search-console.png]]

This is the code that makes this happen:

#+begin_src javascript
function shouldPerformSearch(query) {
  console.log("You clicked the search button! The query is:", query);
  // ~~ EXERCISE 2 CODE GOES HERE ~~
}
#+end_src

Whenever the blue *Search* button is clicked, the ~shouldPerformSearch~ function
is called. Given the name, we should expect that this function performs a
search, but right now it doesn't do much of anything!

Right below ~shouldPerformSearch~ is the function ~searchBooks~.

#+begin_src javascript
function searchBooks(query) {
  // body omitted
}
#+end_src

In the next exercise we'll be focusing on making ~searchBooks~ perform a decent
search; for now, let's just see how it works. Notice how ~searchBooks~ takes a
single argument, ~query~? Instead of logging the ~query~ itself, let's see what
happens when we call ~searchBooks~ with the query. Change ~shouldPerformSearch~
to look like this:

#+begin_src javascript
function shouldPerformSearch(query) {
  console.log("Your search returned:", searchBooks(query));
}
#+end_src

What happens when you press the search button without any text in the field?
What about when there is text?

[[./img/log-basic-search.gif]]

Clearly, the search needs some work. As mentioned before, we'll fix this later;
for now, we can just pretend that it works well and use it regardless.

*Exercises:*

a) Currently, the search either returns an empty array, or an array of books.
Use this information to update the table (~drawTable~) with the result of
~searchBooks~.

b) What happens when you use the search button now? Like before, try it with no
text entered and with text entered. Given the result we saw earlier, does this
make sense?

** Exercise 3: Implement a Search Algorithm

#+begin_src javascript
function isMatch(book) {
  return false; // this is a really bad search
}
#+end_src

The ~isMatch~ function will be called on each book in the ~bookStore~, and
should *return* ~true~ if that book is a match, and ~false~ if not. We'll now
explore a couple of techniques for implementing the search algorithm. When
implementing this function, don't forget ~return~ true or false!

*a)* One way to search our books would be to check if the beginning of the book's
title (=book.title=) was equal to our =query=. JavaScript strings have a method
=substring= that takes two arguments: =begin= and =end=. Try the following at a
console:

#+begin_src javascript
"hello, world".substring(0,3);
"hello, world".substring(3,7);
#+end_src

Given that we can determine the length of our =query= with =query.length=, and
can check equality with ~===~, how can we use =substring= to determine if the
beginning of the book's title matches the =query=?

*b)* How does your =isMatch= function fare with different cases? Change =isMatch=
to be case-insensitive. Hint: try a search for "javascript lowercase string" in
Google.

*c)* Modify =isMatch= to search against a different key in the =book= object (e.g.
author). Having to modify the code itself to search against a different field
doesn't seem like a very good solution; ideally we would like to be able to
search by title /or/ author -- fix this by using the logical *or* operator
(~||~) to check against multiple keys at once. Try the following at a console to
get an idea of how ~||~ works:

#+begin_src javascript
true || true
true || false
false || false
var animal = "monkey";
animal === "giraffe" || animal === "monkey"
#+end_src

*d)* Let's say we're searching for the book "Infinite Jest", and we try searching
for the word "jest" -- does the search work? Why not? Change =isMatch= again so
that it does. The string method =indexOf= can help us here. Try the following to
get an idea of what =indexOf= does:

#+begin_src javascript
"hello, world".indexOf("hello");
"hello, world".indexOf("wor");
"hello, world".indexOf(", w");
"hello, world".indexOf("chimpanzee");
#+end_src
** Exercise 4: Don't Repeat Yourself (DRY)

*a)* You have probably made several calls to ~setTableBody~ at this point, and
 have probably noticed that it was necessary to supply the array of keys as the
 second argument each time -- this is annoying. Let's fix it! First, create a
 new function called ~updateTable~.

 Look at your previous calls to ~setTableBody~ -- of the parameters that you
 have passed to this function, which parameter has changed and which parameter
 has stayed the same? Your new ~updateTable~ function should only take /one/
 argument -- the one that has changed between calls.

*b)* Instead of calling ~setTableBody~ multiple times with arguments that don't
change, we'll /wrap/ calls to ~setTableBody~ with ~updateTable~ so that the
unchanging arguments can be provided *once*, and we can focus on the arguments
that /do/ change. Consider the following example:

#+begin_src javascript
function add(x, y) {
  return x + y;
}
// Let's say we find ourselves adding 10 frequently to some other number:
add(10, 17);
add(10, 3);
add(10, 4);
// Why not have an addTen function?
function addTen(x) {
  return add(10, x);
}
#+end_src

Call ~setTableBody~ inside of ~updateTable~ and provide the unchanging arguments
here. Afterwards, replace all of your previous calls to ~setTableBody~ with
calls to ~updateTable~.
** Exercise 5: Extending Table Functionality

In Exercise 1 we told you that ~setTableBody~ accepted an array of row objects
and an array of string key names to use to look up values from the row objects.
In addition to strings, the second argument can also contain /objects/ -- this
allows us to inject some additional functionality into the table -- specifically
where formatting is concerned. Let's revisit the example in Exercise 1 and see
how this works:

#+begin_src javascript
var objects = [{a: "Hello", b: "World"}, {a: "Dog", b: "Cat"}, {a: "Orange", b: "Banana"}];
function formatA(x) {
  return x + "!";
}

function formatB(x) {
  return x.toUpperCase();
}
setTableBody(objects, [{key: "a", format: formatA},
                       {key: "b", format: formatB}]);
#+end_src

By providing a formatting function, we can alter the way the data /appears/
without altering the data itself.

*a)* Inside of your ~updateTable~ function from the last exercise, declare a new
 function ~formatPrice~ that prefixes the price with a dollar sign (hint: see
 ~formatA~ above for an example of how to do this); then, format the ~price~
 column of each book.

*b)* Pick one of the authors of the books and create a formatting function that
 replaces that author's name with your own.

*c)* ~setTableBody~ can also take a function as a third argument, that, when
  provided, will be called whenever a row is clicked. This function should take
  two arguments: ~book~ and ~row~. Declare this function inside of ~updateTable~
  and pass it as the third argument to ~updateTable~. For now, just
  ~console.log~ the book object (first parameter) inside of the function.
